package cn.edu.gzmu.authorization.user.impl

import cn.edu.gzmu.authorization.common.ORDER_BY_SORT
import cn.edu.gzmu.authorization.common.exception.TransactionException
import cn.edu.gzmu.authorization.common.service.JdbcRepository
import cn.edu.gzmu.authorization.user.User
import cn.edu.gzmu.authorization.user.UserService
import io.vertx.core.*
import io.vertx.core.json.JsonArray
import io.vertx.core.json.JsonObject
import io.vertx.kotlin.ext.sql.sqlOptionsOf

/**
 *
 *
 * @author <a href="https://echocow.cn">EchoCow</a>
 * @date 2019/8/17 下午4:21
 */
class UserServiceImpl(vertx: Vertx) : JdbcRepository(vertx), UserService {

  override fun statusChange(id: Long, status: Boolean, resultHandler: Handler<AsyncResult<Int>>): UserService {
    val statusValue = if (status) 1 else 0
    val promise = Promise.promise<Int>()
    updateOne(STATUS_CHANGE, JsonArray(listOf(statusValue, id)), promise)
    promise.future().setHandler(resultHandler)
    return this
  }

  override fun existOne(
    name: String,
    email: String,
    phone: String,
    resultHandler: Handler<AsyncResult<JsonObject>>
  ): UserService {
    var option = ""
    val params = JsonArray()
    if (name.isNotEmpty()) {
      option += "AND name = ?"
      params.add(name)
    }
    if (email.isNotEmpty()) {
      option += "AND email = ?"
      params.add(email)
    }
    if (phone.isNotEmpty()) {
      option += "AND phone = ?"
      params.add(phone)
    }
    val promise = Promise.promise<JsonObject>()
    retrieveOne(EXIST_USER + option + ORDER_BY_SORT, params, promise)
    promise.future().setHandler(resultHandler)
    return this
  }

  override fun retrievePage(
    name: String,
    email: String,
    phone: String,
    page: Int,
    size: Int,
    resultHandler: Handler<AsyncResult<JsonArray>>
  ): UserService {
    val params = JsonArray(listOf(name, email, phone, (page - 1) * size, size))
    val promise = Promise.promise<JsonArray>()
    retrieve(RETRIEVE_PAGE, params, promise, listOf("pwd"))
    promise.future().setHandler(resultHandler)
    return this
  }

  override fun retrieveUser(userId: Long, resultHandler: Handler<AsyncResult<JsonObject>>): UserService {
    val params = JsonArray().add(userId)
    val promise = Promise.promise<JsonObject>()
    retrieveOne(RETRIEVE_USER, params, promise, listOf("pwd"))
    promise.future().setHandler(resultHandler)
    return this
  }

  override fun createUser(user: User, roles: JsonArray, resultHandler: Handler<AsyncResult<Void>>): UserService {
    val params = JsonArray(
      listOf(
        user.name, user.spell, user.pwd, user.status, user.icon, user.email, user.phone,
        user.onlineStatus, user.sort, user.createUser, user.modifyUser, user.remark, true
      )
    )
    val promise = Promise.promise<Void>()
    client.getConnection { res ->
      if (res.failed()) promise.fail(res.cause())
      else {
        val connection = res.result()
        connection.setOptions(sqlOptionsOf(autoGeneratedKeys = true))
        connection.setAutoCommit(false) { _ ->
          connection.updateWithParams(INSERT_USER, params) { ar1 ->
            if (ar1.succeeded()) {
              val result = ar1.result()
              val id = result.keys.getLong(0)
              val param = roles.toList().map {
                it as JsonObject
                JsonArray(listOf(id, it.getLong("id"), true))
              }
              connection.batchWithParams(INSERT_USER_ROLE, param) { ar2 ->
                if (ar2.succeeded()) {
                  connection.commit {
                    if (it.succeeded()) promise.complete()
                    else promise.fail(it.cause())
                  }
                } else {
                  connection.rollback { promise.fail(TransactionException()) }
                  promise.fail(ar2.cause())
                }
              }
            } else {
              connection.rollback { promise.fail(TransactionException()) }
              promise.fail(ar1.cause())
            }
          }
        }
      }
    }
    promise.future().setHandler(resultHandler)
    return this
  }

  override fun updateUser(user: User, roles: JsonArray, resultHandler: Handler<AsyncResult<Void>>): UserService {
    val params = JsonArray(
      listOf(
        user.name, user.spell, user.pwd, user.status, user.icon, user.email, user.phone,
        user.onlineStatus, user.sort, user.modifyUser, user.remark, user.isEnable,
        user.id
      )
    )
    val promise = Promise.promise<Void>()
    client.getConnection { res ->
      if (res.failed()) promise.fail(res.cause())
      else {
        val connection = res.result()
        connection.setOptions(sqlOptionsOf(autoGeneratedKeys = true))
        connection.setAutoCommit(false) { _ ->
          connection.updateWithParams(UPDATE_USER, params) { ar1 ->
            if (ar1.succeeded()) {
              val id = user.id
              connection.queryWithParams(RETRIEVE_USER_ROLE, JsonArray(listOf(id))) { ar2 ->
                if (ar2.succeeded()) {
                  val result = ar2.result()
                  // 已经存在的角色关联的行
                  val rows = result.rows
                  // 已经存在的角色关联 id
                  val rowRoleIds = rows.map { row -> row.getLong("role_id") }
                  // 需要更新的角色关联的 id
                  val roleIds = roles.toList().map {
                    it as JsonObject
                    it.getLong("id")
                  }
                  // 已经存在的但需要保留的角色关联
                  val existIds = rows.filter { row -> roleIds.contains(row.getLong("role_id")) }
                    .map { JsonArray(listOf(it.getLong("id"))) }
                  val existUpdate = Promise.promise<List<Int>>()
                  connection.batchWithParams(UPDATE_USER_ROLE, existIds, existUpdate)
                  // 已经存在的但不需要保留的角色关联
                  val noExistIds = rows.filter { row -> !roleIds.contains(row.getLong("role_id")) }
                    .map { JsonArray(listOf(it.getLong("id"))) }
                  val noExistDelete = Promise.promise<List<Int>>()
                  connection.batchWithParams(DELETE_USER_ROLE, noExistIds, noExistDelete)
                  // 需要添加的角色关联
                  val addIds = roleIds.filter { !rowRoleIds.contains(it) }
                  val add = Promise.promise<List<Int>>()
                  val addParam = addIds.map { JsonArray(listOf(user.id, it, true)) }
                  connection.batchWithParams(INSERT_USER_ROLE, addParam, add)
                  CompositeFuture.all(existUpdate.future(), noExistDelete.future(), add.future())
                    .setHandler { ar3 ->
                      if (ar3.succeeded()) connection.commit {
                        if (it.succeeded()) promise.complete()
                        else {
                          connection.rollback { promise.fail(TransactionException()) }
                          promise.fail(it.cause())
                        }
                      }
                      else {
                        connection.rollback { promise.fail(TransactionException()) }
                        promise.fail(ar3.cause())
                      }
                    }
                } else {
                  connection.rollback { promise.fail(TransactionException()) }
                  promise.fail(ar2.cause())
                }
              }
            } else {
              connection.rollback { promise.fail(TransactionException()) }
              promise.fail(ar1.cause())
            }
          }
        }
      }
    }
    promise.future().setHandler(resultHandler)
    return this
  }
}
